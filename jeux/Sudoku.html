<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" />
  <title>üî¢ Sudoku</title>
  <link rel="icon" href="../logo/logo.png" type="image/x-icon">
  <link href="https://fonts.googleapis.com/css2?family=Quicksand:wght@600&display=swap" rel="stylesheet">
  <style>
    body {
      margin: 0;
      font-family: 'Quicksand', sans-serif;
      background: linear-gradient(135deg,#fff3cd,#ffe5b4,#ffd1d1,#ffc4e1);
      color: #2c3e50;
      display: flex;
      flex-direction: column;
      align-items: center;
      height: 100vh; /* Fixe la hauteur √† la taille de l'√©cran */
      overflow: hidden; /* Emp√™che le scroll global */
      touch-action: manipulation;
    }

    header {
      width: 100%;
      flex-shrink: 0;
    }

    .container {
      width: 100%;
      max-width: 500px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start; /* Chang√© de space-between √† flex-start */
      padding: 5px;
      gap: 5px; /* Force un petit espace constant entre les blocs */
      box-sizing: border-box;
      flex-grow: 1;
      overflow: hidden;
    }

    .controls {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 2px; /* R√©duit */
      width: 100%;
      justify-content: center;
      flex-wrap: nowrap; /* Emp√™che le passage √† la ligne des boutons du haut */
    }

    select, button {
      padding: 6px 10px;
      border-radius: 8px;
      border: 0;
      font-weight: 600;
      font-family: inherit;
      font-size: 0.85rem;
      cursor: pointer;
    }

    button { background: #ff6f00; color: #fff; }
    #noteBtn { background: #607d8b; min-width: 90px; }
    #noteBtn.active { background: #2196f3; }

    #timer {
      background: rgba(255, 255, 255, 0.4);
      padding: 6px 10px;
      border-radius: 8px;
      font-weight: 700;
      font-size: 0.85rem;
    }

    /* GRILLE : Adaptable selon la hauteur de l'√©cran (vh) */
    .sudoku {
      display: grid;
      grid-template-columns: repeat(9, 1fr);
      width: 95vw;
      height: 95vw;
      max-width: 55vh; /* R√©duit de 65 √† 55 */
      max-height: 55vh; /* R√©duit de 65 √† 55 */
      background: rgba(255, 255, 255, 0.3);
      border: 2px solid #ffb347;
      border-radius: 8px;
      box-shadow: 0 4px 15px rgba(0,0,0,0.1);
    }

    .cell {
      border: 1px solid rgba(255, 111, 0, 0.15);
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(255, 255, 255, 0.4);
    }

    .cell.prefilled { background: rgba(0, 0, 0, 0.08); }
    .cell.selected { background: rgba(255, 235, 59, 0.5) !important; outline: 2px solid #ff6f00; z-index: 2; }
    .cell.highlight-same { background-color: rgba(255, 160, 0, 0.3) !important; }
    .cell.error input { background-color: rgba(233, 30, 99, 0.2); color: #d32f2f; }

    .cell:nth-child(3n) { border-right: 2px solid #ffb347; }
    .cell:nth-child(9n) { border-right: 1px solid rgba(255, 111, 0, 0.15); }
    .cell:nth-child(n+19):nth-child(-n+27), 
    .cell:nth-child(n+46):nth-child(-n+54) { border-bottom: 2px solid #ffb347; }

    .cell input {
      width: 100%; height: 100%; text-align: center; border: 0;
      background: transparent; font-size: 1.4rem; font-weight: 700;
      pointer-events: none; color: #333;
    }

    .pencil-notes {
      position: absolute; inset: 0; display: grid;
      grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(3, 1fr);
      pointer-events: none; padding: 1px;
    }
    .pencil-notes span { font-size: 0.5rem; color: #607d8b; display: flex; align-items: center; justify-content: center; }

    .num-pad {
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 6px;
      margin-top: 5px;
      margin-bottom: 5px;
      width: 100%;
      max-width: 450px;
    }

    .num-pad button {
      height: 38px; /* R√©duit pour gagner de la place */
      font-size: 1.1rem;
      background: #ff9a00;
      box-shadow: 0 3px 0 #e68a00;
      border-radius: 8px;
    }

    .num-pad button.completed {
      background: #b0bec5 !important;
      box-shadow: 0 3px 0 #90a4ae !important;
      opacity: 0.6;
      pointer-events: none;
    }

    .num-pad button.erase { background: #d9534f; box-shadow: 0 3px 0 #c9302c; }
    /* --- MODALE DE FIN --- */
    .modal {
      position: fixed; inset: 0; background: rgba(0,0,0,0.7);
      display: flex; align-items: center; justify-content: center; z-index: 1000;
      opacity: 0; pointer-events: none; transition: opacity 0.3s;
    }
    .modal.active { opacity: 1; pointer-events: auto; }

    .modal-content {
      background: white; padding: 25px; border-radius: 20px; text-align: center;
      width: 85%; max-width: 320px; box-shadow: 0 10px 25px rgba(0,0,0,0.2);
      transform: scale(0.8); transition: transform 0.3s;
    }
    .modal.active .modal-content { transform: scale(1); }

    .modal-content h2 { color: #ff6f00; margin: 0 0 15px; }
    .result-time { font-size: 2rem; font-weight: 800; color: #2c3e50; margin-bottom: 5px; }
    .record-badge { 
      display: inline-block; background: #ffeb3b; color: #827717; 
      padding: 4px 12px; border-radius: 20px; font-size: 0.8rem; 
      font-weight: 700; margin-bottom: 20px; visibility: hidden;
    }
    .record-badge.visible { visibility: visible; animation: pulse 1s infinite; }

    .modal-btns { display: flex; flex-direction: column; gap: 10px; }
    .modal-btns button { padding: 12px; font-size: 1rem; }
    .btn-quit { background: #607d8b; }

    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }
/* Effets de survol (uniquement pour les appareils avec souris) */
    @media (hover: hover) {
      button:hover {
        background: #ff8f00;
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(0,0,0,0.15);
      }

      #noteBtn:hover { background: #78909c; }
      
      .num-pad button:hover {
        background: #ffa726;
        transform: translateY(-2px);
      }
    }

    /* Effet d'activation (quand on clique) */
    button:active, .num-pad button:active {
      transform: translateY(1px);
      box-shadow: 0 1px 0 #e68a00;
    }

    .num-pad button.erase:active {
      box-shadow: 0 1px 0 #c9302c;
    }
  </style>
</head>
<body>
  <script src="../header.js"></script>
  <script>
    if(typeof injectHeader === 'function') {
      injectHeader({ title: "Sudoku", homeLink: "../accueil.html", showHome: true });
    }
  </script>

  <div class="container">
    <div class="controls">
      <select id="difficulty">
        <option value="35">Facile</option>
        <option value="45" selected>Moyen</option>
        <option value="55">Difficile</option>
      </select>
      <button id="newBtn">Nouveau</button>
      <button id="noteBtn">‚úé Note: OFF</button>
      <div id="timer">00:00</div>
    </div>

    <div id="sudoku" class="sudoku"></div>

    <div class="num-pad">
      <button data-num="1">1</button>
      <button data-num="2">2</button>
      <button data-num="3">3</button>
      <button data-num="4">4</button>
      <button data-num="5">5</button>
      <button data-num="6">6</button>
      <button data-num="7">7</button>
      <button data-num="8">8</button>
      <button data-num="9">9</button>
      <button data-num="0" class="erase">‚úñ</button>
    </div>
  </div>
    <div id="endModal" class="modal">
    <div class="modal-content">
      <h2 id="modalTitle">Bravo !</h2>
      <div class="result-time" id="finalTime">00:00</div>
      <div id="recordBadge" class="record-badge">üèÜ NOUVEAU RECORD !</div>
      <div class="modal-btns">
        <button id="modalPlayAgain">Rejouer</button>
        <button id="modalQuit" class="btn-quit">Quitter</button>
      </div>
    </div>
  </div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-auth.js";
import { getDatabase, ref, set, get, update, remove } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js";

const firebaseConfig = {
    apiKey: "AIzaSyB29fMpTwBgsqkjijkNoQJ2kGChSeQDX_w",
    authDomain: "quiz-ea203.firebaseapp.com",
    databaseURL: "https://quiz-ea203-default-rtdb.europe-west1.firebasedatabase.app",
    projectId: "quiz-ea203",
    storageBucket: "quiz-ea203.firebasestorage.app",
    messagingSenderId: "605137421110",
    appId: "1:605137421110:web:289e0876fe06108deaa997"
};

const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const db = getDatabase(app);

// --- VARIABLES D'√âTAT ---
let solution = [], puzzle = [], state = []
let selectedCell = null;
let isNoteMode = false;
let timerInterval, seconds = 0;
let currentUserUid = null;
let notes = Array.from({length:9}, () => Array.from({length:9}, () => new Set()));

const gridEl = document.getElementById('sudoku');
const noteBtn = document.getElementById('noteBtn');
const difficultySelect = document.getElementById('difficulty');

// --- LOGIQUE DE PERSISTANCE ---

async function saveSession() {
    // Pr√©paration des donn√©es communes
    const serializableNotes = notes.map(row => 
        row.map(cellSet => Array.from(cellSet || []))
    );

    const sessionData = {
        puzzle: puzzle,
        solution: solution,
        state: state,
        seconds: seconds,
        difficulty: difficultySelect.value,
        notes: serializableNotes,
        timestamp: new Date().toISOString()
    };

    // Cas 1 : Utilisateur connect√© -> Firebase
    if (currentUserUid) {
        try {
            await set(ref(db, `users/${currentUserUid}/games/sudoku/session`), sessionData);
        } catch (e) { 
            console.error("Erreur sauvegarde Firebase:", e); 
        }
    } 
    // Cas 2 : Mode invit√© -> LocalStorage
    else {
        localStorage.setItem('sudoku_guest_session', JSON.stringify(sessionData));
    }
}

async function restoreSession() {
    let data = null;

    try {
        // 1. R√©cup√©ration des donn√©es (Firebase ou Local)
        if (currentUserUid) {
            const snap = await get(ref(db, `users/${currentUserUid}/games/sudoku/session`));
            if (snap.exists()) data = snap.val();
        } else {
            const localData = localStorage.getItem('sudoku_guest_session');
            if (localData) data = JSON.parse(localData);
        }

        if (data) {
            // Restauration des variables de base
            puzzle = data.puzzle;
            solution = data.solution;
            state = data.state;
            seconds = data.seconds || 0;
            difficultySelect.value = data.difficulty;
            
            // 2. RECONSTRUCTION DES NOTES (La partie qui posait erreur)
            let restoredNotes = Array.from({length: 9}, () => 
                Array.from({length: 9}, () => new Set())
            );

            if (data.notes) {
                // 1. On parcourt les entr√©es pour garder les index r√©els [r]
                Object.entries(data.notes).forEach(([r, rowData]) => {
                    const rowIndex = parseInt(r);
                    if (rowData && rowIndex < 9) {
                        
                        // 2. On parcourt les entr√©es de la ligne pour garder les index r√©els [c]
                        Object.entries(rowData).forEach(([c, cellData]) => {
                            const colIndex = parseInt(c);
                            if (Array.isArray(cellData) && colIndex < 9) {
                                
                                // 3. On remplit le Set √† la position exacte
                                cellData.forEach(num => {
                                    if (restoredNotes[rowIndex] && restoredNotes[rowIndex][colIndex]) {
                                        restoredNotes[rowIndex][colIndex].add(Number(num));
                                    }
                                });
                            }
                        });
                    }
                });
            }
            
            notes = restoredNotes;
            
            // 3. Application du rendu
            renderGrid();
            startTimer(true);
            return true;
        }
    } catch (e) { 
        console.error("Erreur restauration d√©taill√©e:", e); 
    }
    return false;
}

// --- LOGIQUE DU JEU ---

async function initGame() {
    seconds = 0; // Reset du temps pour un nouveau jeu
    generateSudoku();
    renderGrid();
    startTimer();
    if (currentUserUid) {
        await remove(ref(db, `users/${currentUserUid}/games/sudoku/session`));
    } else {
        localStorage.removeItem('sudoku_guest_session'); // Nettoyage local
    }
}

function generateSudoku() {
    solution = Array.from({length:9}, () => Array(9).fill(0));
    fillGrid(solution);
    const emptyCells = parseInt(difficultySelect.value);
    puzzle = solution.map(row => [...row]);
    let count = 0;
    while (count < emptyCells) {
        let r = Math.floor(Math.random()*9), c = Math.floor(Math.random()*9);
        if (puzzle[r][c] !== 0) { puzzle[r][c] = 0; count++; }
    }
    state = puzzle.map(row => [...row]);
    
    // Initialisation propre des notes (9x9 Sets vides)
    notes = Array.from({length:9}, () => Array.from({length:9}, () => new Set()));
}

function fillGrid(grid) {
    for (let i = 0; i < 81; i++) {
        let r = Math.floor(i/9), c = i%9;
        if (grid[r][c] === 0) {
            let nums = [1,2,3,4,5,6,7,8,9].sort(() => Math.random() - 0.5);
            for (let n of nums) {
                if (isValid(grid, r, c, n)) {
                    grid[r][c] = n;
                    if (fillGrid(grid)) return true;
                    grid[r][c] = 0;
                }
            }
            return false;
        }
    }
    return true;
}

function isValid(grid, r, c, n) {
    for (let i = 0; i < 9; i++) if (grid[r][i] === n || grid[i][c] === n) return false;
    let br = Math.floor(r/3)*3, bc = Math.floor(c/3)*3;
    for (let i=0; i<3; i++) for (let j=0; j<3; j++) if (grid[br+i][bc+j] === n) return false;
    return true;
}

function renderGrid() {
    gridEl.innerHTML = '';
    // On cr√©e un fragment pour am√©liorer les performances
    const fragment = document.createDocumentFragment();

    for (let r = 0; r < 9; r++) {
        for (let c = 0; c < 9; c++) {
            const cell = document.createElement('div');
            cell.className = 'cell';
            if (puzzle[r][c] !== 0) cell.classList.add('prefilled');
            cell.dataset.r = r; 
            cell.dataset.c = c;
            
            const input = document.createElement('input');
            input.value = state[r][c] || '';
            input.readOnly = true;
            
            const notesDiv = document.createElement('div');
            notesDiv.className = 'pencil-notes';
            
            cell.append(notesDiv, input);
            fragment.appendChild(cell);
            
            cell.addEventListener('click', () => select(cell));
            
            // On g√®re les erreurs
            if (state[r][c] !== 0 && state[r][c] !== solution[r][c]) {
                cell.classList.add('error');
            }

            // Important: on remet la classe selected si c'√©tait celle-l√†
            if (selectedCell && selectedCell.dataset.r == r && selectedCell.dataset.c == c) {
                cell.classList.add('selected');
            }
        }
    }
    gridEl.appendChild(fragment);

    // CRUCIAL : On met √† jour les notes apr√®s avoir ajout√© toute la grille au DOM
    requestAnimationFrame(() => {
        for (let r = 0; r < 9; r++) {
            for (let c = 0; c < 9; c++) {
                const cell = gridEl.querySelector(`[data-r="${r}"][data-c="${c}"]`);
                if (cell) updateCellNotes(r, c, cell);
            }
        }
    });

    updateNumPad();
}

function select(cell) {
    if(!cell) return;
    document.querySelectorAll('.cell').forEach(c => c.classList.remove('selected', 'highlight-same'));
    selectedCell = cell;
    cell.classList.add('selected');
    const val = state[cell.dataset.r][cell.dataset.c];
    if (val) {
        document.querySelectorAll('.cell').forEach(c => {
            if (state[c.dataset.r][c.dataset.c] == val) c.classList.add('highlight-same');
        });
    }
}

function updateCellNotes(r, c, cell) {
    const notesDiv = cell.querySelector('.pencil-notes');
    if (!notesDiv) return;
    notesDiv.innerHTML = '';
    
    // VERIFICATION : On s'assure que la ligne et la cellule existent dans l'objet notes
    if (state[r] && state[r][c] === 0 && notes[r] && notes[r][c]) {
        for (let i = 1; i <= 9; i++) {
            const span = document.createElement('span');
            // On v√©rifie si i est dans le Set
            span.textContent = notes[r][c].has(i) ? i : '';
            notesDiv.appendChild(span);
        }
    }
}

async function handleInput(n) {
    if (!selectedCell) return;
    const r = parseInt(selectedCell.dataset.r), c = parseInt(selectedCell.dataset.c);
    
    // S√©curit√© : Si notes[r] n'existe pas pour une raison quelconque, on le recr√©e
    if (!notes[r]) notes[r] = Array.from({length:9}, () => new Set());
    if (!notes[r][c]) notes[r][c] = new Set();

    if (puzzle[r][c] !== 0) return;

    if (isNoteMode && n !== 0) {
        if (notes[r][c].has(n)) notes[r][c].delete(n);
        else notes[r][c].add(n);
        state[r][c] = 0; 
    } else {
        state[r][c] = n;
        notes[r][c].clear();
    }
    
    renderGrid();
    // Replacer le focus sur la cellule apr√®s le render
    const newCell = document.querySelector(`[data-r="${r}"][data-c="${c}"]`);
    if(newCell) select(newCell);
    
    updateNumPad();
    saveSession(); 
    checkWin();
}


function updateNumPad() {
    const counts = {};
    for (let i = 1; i <= 9; i++) counts[i] = 0;
    document.querySelectorAll('.cell').forEach(cell => {
        const val = state[cell.dataset.r][cell.dataset.c];
        if (val !== 0 && !cell.classList.contains('error')) counts[val]++;
    });
    document.querySelectorAll('.num-pad button[data-num]').forEach(btn => {
        const n = parseInt(btn.dataset.num);
        if (n !== 0 && counts[n] >= 9) btn.classList.add('completed');
        else btn.classList.remove('completed');
    });
}

function startTimer(resume = false) {
    clearInterval(timerInterval);
    if (!resume) {
        seconds = 0; // On ne reset que si c'est une NOUVELLE partie
    }
    
    const display = () => {
        const m = Math.floor(seconds/60).toString().padStart(2,'0');
        const s = (seconds%60).toString().padStart(2,'0');
        document.getElementById('timer').textContent = `${m}:${s}`;
    };

    display();
    timerInterval = setInterval(() => {
        seconds++;
        display();
        // Sauvegarde automatique du temps toutes les 30 secondes
        if (seconds % 30 === 0) saveSession(); 
    }, 1000);
}

// --- FONCTION CHECKWIN AM√âLIOR√âE AVEC STATS ---
async function checkWin() {
    let errors = document.querySelectorAll('.cell.error').length;
    let full = state.flat().every(v => v !== 0);
    
    if (full && errors === 0) {
        clearInterval(timerInterval);
        const finalSeconds = seconds;
        
        // RECUP√âRATION DE LA DIFFICULT√â R√âELLE
        // On s'assure d'avoir la valeur au moment pr√©cis de la victoire
        const diffValue = document.getElementById('difficulty').value;
        
        // Traduction optionnelle pour avoir des noms clairs dans Firebase
        const diffNames = { "35": "facile", "45": "moyen", "55": "difficile" };
        const diffKey = diffNames[diffValue] || diffValue;

        if (currentUserUid) {
            // 1. Supprimer la session
            await remove(ref(db, `users/${currentUserUid}/games/sudoku/session`));

            // 2. Chemin sp√©cifique √† la difficult√© : .../stats/facile/
            const statsPath = `users/${currentUserUid}/games/sudoku/stats/${diffKey}`;
            
            try {
                const snap = await get(ref(db, statsPath));
                let stats = snap.exists() ? snap.val() : { 
                    bestTime: Infinity, 
                    gamesWon: 0, 
                    totalTime: 0,
                    averageTime: 0 
                };

                // Mise √† jour
                stats.gamesWon += 1;
                stats.totalTime += finalSeconds;
                stats.averageTime = Math.round(stats.totalTime / stats.gamesWon);

                let isRecord = false;
                if (finalSeconds < stats.bestTime) {
                    stats.bestTime = finalSeconds;
                    isRecord = true;
                }

                // SAUVEGARDE DANS LE DOSSIER DE DIFFICULT√â
                await set(ref(db, statsPath), stats);

                showEndModal(finalSeconds, isRecord);
            } catch (error) {
                console.error("Erreur Firebase:", error);
            }
        } else {
            localStorage.removeItem('sudoku_guest_session');
            showEndModal(finalSeconds, false);
        }
    }
}

function showEndModal(totalSeconds, isRecord) {
    const m = Math.floor(totalSeconds/60).toString().padStart(2,'0');
    const s = (totalSeconds%60).toString().padStart(2,'0');
    
    document.getElementById('finalTime').textContent = `${m}:${s}`;
    const badge = document.getElementById('recordBadge');
    if (isRecord) badge.classList.add('visible');
    else badge.classList.remove('visible');

    document.getElementById('endModal').classList.add('active');
}

// --- √âV√âNEMENTS DE LA MODALE ---
document.getElementById('modalPlayAgain').onclick = () => {
    document.getElementById('endModal').classList.remove('active');
    initGame();
};

document.getElementById('modalQuit').onclick = () => {
    window.location.href = "../accueil.html"; // Ou ton lien de retour
};
// --- INITIALISATION & √âV√âNEMENTS ---

// --- INITIALISATION & √âV√âNEMENTS ---

onAuthStateChanged(auth, async (user) => {
    // 1. On r√©cup√®re le profil choisi dans le localStorage (priorit√© absolue)
    const savedUid = localStorage.getItem('active_uid');
    currentUserUid = savedUid || (user && !user.isAnonymous ? user.uid : null);

    // 3. Tentative de restauration (la fonction restoreSession g√©rera Firebase vs Local toute seule)
    const restored = await restoreSession();
    
    if (!restored) {
        initGame();
    } 
});

noteBtn.onclick = () => {
    isNoteMode = !isNoteMode;
    noteBtn.classList.toggle('active', isNoteMode);
    noteBtn.textContent = isNoteMode ? "‚úé Note: ON" : "‚úé Note: OFF";
};

document.getElementById('newBtn').onclick = initGame;

document.querySelectorAll('.num-pad button[data-num]').forEach(btn => {
    btn.onclick = () => handleInput(parseInt(btn.dataset.num));
});

document.addEventListener('keydown', (e) => {
    if (!selectedCell) return;
    const r = parseInt(selectedCell.dataset.r), c = parseInt(selectedCell.dataset.c);
    if (e.key >= '1' && e.key <= '9') handleInput(parseInt(e.key));
    else if (['Backspace', 'Delete', '0'].includes(e.key)) handleInput(0);
    else if (e.key.startsWith('Arrow')) {
        let nr = r, nc = c;
        if (e.key === 'ArrowUp') nr = Math.max(0, r - 1);
        if (e.key === 'ArrowDown') nr = Math.min(8, r + 1);
        if (e.key === 'ArrowLeft') nc = Math.max(0, c - 1);
        if (e.key === 'ArrowRight') nc = Math.min(8, c + 1);
        select(document.querySelector(`[data-r="${nr}"][data-c="${nc}"]`));
    }
});
</script>
</body>
</html>